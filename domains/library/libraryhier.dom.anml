type Object with{
    variable Loc at;
};
type Loc with {
    predicate empty();
};
type Location < Loc ;

type Arm < Loc;
constant boolean atRightl(Location l1,Location l2);
//constant Location atRightl(Location l);
constant boolean atRightb(Object l1,Object l2);
constant boolean atRightp(Position p1,Position p2);

type Position;

instance Position robot;
 
function Position robotPos();

constant Position pos(Loc l);

action goto(Position p1, Position p2){
	duration :in [3,4];
	[all]robotPos == p1 :-> p2;
};

action place (Object o, Location l, Arm a, Position p){
	motivated;
	[all] robotPos == p;
	pos(l) == p;
	duration := 5;
	[all] {
		a.empty == false :-> true;
        o.at == a :-> l;
		l.empty == true :-> false;
	};
};

action pick (Object o, Location l, Arm a, Position p){
	motivated;
	[all] robotPos == p;
	pos(l) == p;
	duration := 5;
	[all] {
		l.empty == false :-> true;
		o.at == l :-> a;
		a.empty == true :-> false;
	};
};

action moveToEmpty(Object o, Location ls, Location le, Position pe, Position pl){
	motivated;
	:decomposition{
		pe != robot;
		constant Arm a;
		[all] contains {
			pi : pick(o,ls,a,pe);
			pl : place(o,le,a,pl);
		};
		end(pi) < start(pl);
	};
	:decomposition{
		pe == robot;
		[all] contains 	pl : place(o,le,ls,pl);
	};
};
	


action sort2 (Loc l0, Loc l1) {
	constant Object b0;
	constant Object b1;
	[start]{
		b0.at == l0;
		b1.at == l1;
	};
	:decomposition{
		atRightl(l0,l1) == true;
		atRightb(b0,b1) == false;
		[all] contains change(b0,b1,l0,l1);
	};
	:decomposition{
		atRightl(l0,l1) == true;
		atRightb(b0,b1) == true;
	};
	:decomposition{
		atRightl(l0,l1) == false;
		atRightb(b0,b1) == false;
	};
	:decomposition{
		atRightl(l0,l1) == false;
		atRightb(b0,b1) == true;
		[all] contains change(b0,b1,l0,l1);
	};
}; 

action change (Object o1, Object o2, Location l1, Location l2){
	motivated;
	constant Arm a1;
	constant Arm a2;
	constant Position p1;
	constant Position p2;
	a1 != a2;
	[start] a1.empty == true; 
	[start] a2.empty == true;
	[all] contains {
		a : pick(o1,l1,a1,p1); 
		b : pick(o2,l2,a2,p2); 
		c : place(o1,l2,a1,p2);
		d : place(o2,l1,a2,p1);
	};
	end(a) < start (c);
	end(b) < start (c);
	end(a) < start (d);
	end(b) < start (d);
};

