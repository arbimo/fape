// Domain : Temporal Machine Shop Time (Temporally Expressive)

type Piece with{
	predicate baking();
	predicate treated();
	predicate baked();
};

type Kiln with{
	predicate ready();
	predicate empty();
};

variable boolean energy;
predicate structured(Piece p1, Piece p2);
predicate bakedStructure(Piece p1, Piece p2);


constant integer fireTime(Kiln k);
constant integer bakeTime(Piece p);
constant integer treatTime(Piece p);

action fire(Kiln k){
	duration := fireTime(k);
    [all] energy == true;
    [start] k.ready := true ;
    [start+1,end-1] k.ready == true; 
	[end] k.ready == true :-> false;
};

action bake(Kiln k, Piece p){
	duration := bakeTime(p);
	[all] k.ready == true;
	[start] k.empty == true :-> false;
	[start+1,end-1] k.empty == false;
	[end] k.empty == false :-> true;
    [start] p.baking := true ;
	[start+1,end-1] p.baking == true;
	[end] {
       	 p.baking == true :-> false ;
       	 p.baked := true ;
	};
};

action treat(Piece p){
	duration := treatTime(p);
	[all] p.baking == true;
	[end] p.treated := true;
};

action makeStructure(Piece p1, Piece p2){
	p1!=p2;
	constant Kiln uk1;
	constant Kiln uk2;
	[all] contains {
		b1 : bake(uk1,p1);
		b2 : bake(uk2,p2);
		t1 : treat(p1);
		t2 : treat(p2);
	};
	start(b1) < start(t1) ;
	start(b2) < start(t2) ;
	end(t1) < end(b1);
	end(t2) < end(b2);
	[end] structured(p1, p2) := true;
};

action bakeStructure(Piece p1, Piece p2, Kiln k){
	motivated;
	p1!=p2;
	duration := 18;
	[all] k.ready == true;
	[start] k.empty == true :-> false;
	[start+1,end-1] k.empty == false;
	[end] k.empty :=  true;
	[start] structured(p1, p2) == true;
    [end] bakedStructure(p1,p2) := true;
};

action bakeStructureH(Piece p1, Piece p2, Kiln k){
	[all] contains {
		m : makeStructure(p1,p2);
		b : bakeStructure(p1, p2, k);
	};
	end(m) < start(b);
};
