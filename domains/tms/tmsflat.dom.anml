// Domain : Temporal Machine Shop, Time (Temporally Expressive)

type Piece with{
	predicate baking();
	predicate treated();
	predicate baked();
};

type Kiln with{
	predicate ready();
	predicate empty();
};

variable boolean energy;
predicate structured(Piece p1, Piece p2);
predicate bakedStructure(Piece p1, Piece p2);


constant integer fireTime(Kiln k);
constant integer bakeTime(Piece p);
constant integer treatTime(Piece p);

action fire(Kiln k){
	duration := fireTime(k);
    [all] energy == true;
    [start] k.ready := true ;
    [start+1,end-1] k.ready == true; 
	[end] k.ready := false;
};

action bake(Kiln k, Piece p){
	duration := bakeTime(p);
	[all] k.ready == true;
	[start] k.empty == true :-> false;
	[start+1,end-1] k.empty == false;
	[end] k.empty == false :-> true;
    [start] p.baking := true ;
	[start+1,end-1] p.baking == true;
	[end] {
       	 p.baking == true :-> false ;
       	 p.baked := true ;
	};
};

action treat(Piece p){
	duration := treatTime(p);
	[all] p.baking == true;
	[end] p.treated := true;
};

action makeStructure(Piece p1, Piece p2){
	p1!=p2;
 	duration := 3;
	[all] {
		p1.baked == true;
		p2.baked == true;
		p1.treated == true;
		p2.treated == true;
	};
	[end] structured(p1, p2) := true;
};

action bakeStructure(Piece p1, Piece p2, Kiln k){
	p1!=p2;
	duration := 10;
	[all] k.ready == true;
	[all] structured(p1, p2) == true;
	[start] k.empty == true;
	[start+1] k.empty := false;
	[end] k.empty := true;
	[end] bakedStructure(p1,p2) := true;
};
