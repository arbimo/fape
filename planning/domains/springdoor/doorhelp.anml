// -*-c++-*-
// the turn&open door domain for spring-doors which close when not held
// involve communication between robots, request and help
// simple version: one arm robots, implicit knob grasping actions, no space constraints

//*** types ***

type places ;

type rooms < places;

type objects_doors ;

type objects < objects_doors with {
  variable rooms pos; };

type doors < objects_doors with {
  predicate unlatched (); 
  predicate open();
  predicate helprequested(); };

type robots with {
  variable places loc;
  variable objects_doors grasp;
  predicate busy();};


constant boolean adjacent(places from, places tp);
constant boolean connect(doors d, places from, places to) ;


//constant boolean path(places from, places next, place to) ;
// path between places either adjacent or connected with doors
// needs to be generated from an all-shortest-path preprocessing.

instance objects_doors empty ; //denotes an empty handed robot
instance rooms held; //denotes the position of an object held by a robot


//*** primitives ***

action pickup (robots r, objects o, rooms p) {
  motivated ;
  [all] {
    r.loc == p;
    r.grasp == empty :-> o ;
    o.pos == p :-> held ;} ;
};

action drop (robots r, objects o, rooms p) {
  motivated ;
  [all] {
    r.loc == p;
    r.grasp == o :-> empty ;
    o.pos == held :-> p ;} ;
};

// elementary move from a room to adjacent door or the opposite
action move (robots r, places from, places to) {
  motivated ;
  adjacent(from, to) ;
  [all] r.loc == from :-> to; 
};

action turnknob (robots r, doors d) {
  motivated ;
  constant places from ;
  constant places to ;
  connect(d, from, to);
  [all] {
    r.loc == from;
    r.grasp == empty :-> d ;
    d.open == false ;
    d.unlatched == false :-> true ;};
};

action revolvehold (robots r, doors d) {
  motivated ;
  constant places from ;
  constant places to ;
  connect(d, from, to);
  [start] r.loc == from ;
  [all] {
    r.grasp == d :->  empty ;
    d.unlatched == true :-> false ;};
  [start, start+1] d.open == false :-> true ;
  [start+1, end] d.open == true ;
  [end + 1] d.open := false ;
  //[all] d.open == false :-> true ;
};

action passthru (robots r, doors d) {
  motivated ;
  constant places from ;
  constant places to ;
  connect(d, from, to);
  [all]{
    d.open == true ;
    r.loc == from :-> to ;};
};

action requesthelp (robots r, doors d) {
  motivated ;
  [all]{
    d.helprequested == false :-> true ;};
};


//*** tasks ***

action opendoor (robots r, doors d) {
  motivated ;
  constant places from ;
  constant places to ;
  connect(d, from, to);
  :decomposition {
    [all] r.loc == from ;
    [start] r.grasp == empty ;
    [all] contains {
    s1 : turnknob(r, d) ;
    s2 : revolvehold(r, d) ;};
    end(s1) <= start(s2);
  };
};

action openpassdoor (robots r, doors d) {
  motivated ;
  constant places from ;
  constant places to ;
  connect(d, from, to);
  :decomposition {
    [start] {
      r.grasp == empty ;
      r.loc == from ;};
    [all] contains {
    s1 : turnknob(r, d) ;
    s2 : revolvehold(r, d);
    s3: passthru(r, d);};
    end(s1) <= start(s2);
    start(s2) <= start(s3);
    end(s3) <= end(s2);
  };
};

action goto (robots r, places from, places to) {
  motivated ;
  [start] r.loc == from ;
  :decomposition {
    adjacent(from, to);
    [all] move(r, from, to);
  };
  :decomposition { //r empty handed
    constant doors d;
    connect(d, from, to);
    [start] r.grasp == empty ;
    [all] openpassdoor(r, d);
  };
  :decomposition { // r not empty handed
    constant doors d;
    constant objects o;
    connect(d, from, to);
    [start] r.grasp == o ;
    o != empty ;
    [start] d.helprequested == false ;
    [all] contains {
    s0: requesthelp(r,d);
    s1 : passthru(r, d);} ;
    end(s0) <= start(s1) ;
    [end] d.helprequested := false ; //r signals it finished passing
  };
  :decomposition { // simple recursion
    constant places next ;
    adjacent(from, next) ;
    [all] contains { 
    s1 : move(r, from, next);
    s2 : goto(r, next, to);};
    end(s1) <= start(s2);
  };
  :decomposition { // double recursion
    constant places next ;
    constant doors d;
    connect(d, from, next) ;
    [all] contains {
    s1 : goto(r, from, next);
    s2 : goto(r, next, to);};
    end(s1) <= start(s2);
  };
};

// r helps another robot
action help (robots r, doors d) {
  //  motivated ;
  constant places from; // close to d ?
  constant places to;
  constant places nextp ;
  connect(d, to, nextp);
  [start] d.helprequested == true;
  [start] r.loc==from ;
  [start, start+1] r.busy==false :-> true ;
  [end] r.busy:= false ;
  [start, infinity] contains h: d.helprequested == false ;
  [all] contains {
  s1: goto(r, from, to);
  s2: opendoor(r, d) ;};
   end(s1) <= start(s2);
   start(h) <= end(s2);
};
  
action fetch (objects o, rooms p) {
  motivated ;
  constant robots r ;
  constant places from ;
  :decomposition {
    [start] o.pos == p ;
  };
  :decomposition {
    [start] {
      o.pos == held ;
      r.grasp == o ;
      r.loc == from ;};
    [all] contains {
    s1: goto(r, from, p) ;
    s2: drop(r, o, p) ;};
    end(s1) <= start(s2) ;
  };
  :decomposition{
    constant rooms oinit;
    [start] {
      o.pos == oinit ;
      r.loc == from ;};
    //    [all] r.busy==false :=true := false ;
    [start, start+1] r.busy==false :-> true ;
    [end] r.busy:= false ;
    oinit != p ;
    [all] contains {
    s1: goto(r, from, oinit);
    s2: pickup(r,o);
    s3: goto(r, oinit, p);
    s4: drop(r, o, p);};
    end(s1) <= start(s2);
    end(s2) <= start(s3);
    end(s3) <= start(s4);
  };
};


/*  Draft
action waittoopen(robots r, doors d) {
  connect(doors d, places p1, places p2);
  [all] r.loc == p1;
  [start] d.open == false;
  [end] d.open == true ;
};
in goto
  :decomposition {
    constant doors d;
    connect(d, from, to);
    [start] r.grasp != empty ;
    [start] d.helprequested == true ; //not sure this case arrises ?
    [all] contains {
    s1 : waittoopen(r, d);
    s2 : passthru(r, d);}
    end(s1) <= start(s2);
    [end] d.helprequested := false ;
    };*/
